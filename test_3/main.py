# random_matrix = [
#    [9, 2, 1],
#    [2, 5, 3],
#    [4, 8, 5]
# ]
# #
# for row in random_matrix:
#    min_value = min(row) # осуществляем поиск минимального значения в списке row
#    max_value= max(row) # осуществляем поиск максимального значения в списке row
#    # Далее используем функцию index из ранее пройденного материала и определяем
#    # индексы максимального и минимального элементов в списках "random_matrix" и "row".
#    index_random_matrix = random_matrix.index(row)+1
#    min_index_rows = row.index(min_value)+1
#    max_index_rows = row.index(max_value)+1
#
#    # Выводим все это дело на экран
#    print(f"Мин. значение в {index_random_matrix} строке массива равно: {min_value}. "
#          f"Индекс мин. элемента в массиве:  ({index_random_matrix}, {min_index_rows}).")
#
#    print(f"Макс значение в {index_random_matrix} строке массива равно: {max_value}. "
#          f"Индекс макс. элемента в массиве:  ({index_random_matrix}, {max_index_rows}).")
#    print()

#*****************************************************************************************
# ЗАДАНИЕ 3.8.1 Напишите цикл, который ищет наибольший элемент в матрице.
# test_matrix = [
#                [1, 2, 3],
#                [7, -1, 2],
#                [123, 2, -1]
#                ]
# # определим переменную max_value, которой присвоим значение первого элемента матрицы
# max_value = test_matrix[0][0]
# for row in test_matrix:
#     if max(row) > max_value: # сравнивание максимальное значение из элементов списка "row" со значением max_value
#         max_value = max(row) # если находим среди элементов списка "row" большое значение, то присваиваем это значение переменной max_value
#     print(f"Макс в ряду: {max_value}") # выводим максимальное значение в строке
# print(f"Максимальное значение матрицы: {max_value}") # выводим максимальное значение в матрице
# #***************************************

# # Задание 3.8.2
# # Напишите код, который определяет, является ли матрица квадратной (то есть количество строк равно количеству столбцов). В конце программа должна выводить на экран значение True или False в зависимости от заданной матрицы. Используйте матрицу из предыдущей задачи.
# # Помните, что количество элементов в каждой строке должно быть одинаковым.
# test_matrix = [[1, 2, 3],
#                [7, -1,3],
#                [123, 2, -1]]
# kvadrat = True # Определим булеву переменную kvadrat, которая будем иметь значение True, если матрица квадратная
# for row in test_matrix:
#     if len(row) != len(test_matrix): # если длина строки матрицы не равна количеству строк, то матрица НЕ квадратная
#         kvadrat = False
#         break
# print(kvadrat)


# list_ = [-5, 2, 4, 8, 12, -7, 5]
# print(list(enumerate(list_)))
# for i, value in enumerate(list_):
#     print("Индекс элемента: ", i)
#     print("Значение элемента: ", value)  # с помощью индекса получаем значение элемента
#     print("---")
# print("Конец цикла")
#***************************************
# text = """
# У лукоморья дуб зелёный;
# Златая цепь на дубе том:
# И днём и ночью кот учёный
# Всё ходит по цепи кругом;
# Идёт направо -- песнь заводит,
# Налево -- сказку говорит.
# Там чудеса: там леший бродит,
# Русалка на ветвях сидит;
# Там на неведомых дорожках
# Следы невиданных зверей;
# Избушка там на курьих ножках
# Стоит без окон, без дверей;
# Там лес и дол видений полны;
# Там о заре прихлынут волны
# На брег песчаный и пустой,
# И тридцать витязей прекрасных
# Чредой из вод выходят ясных,
# И с ними дядька их морской;
# Там королевич мимоходом
# Пленяет грозного царя;
# Там в облаках перед народом
# Через леса, через моря
# Колдун несёт богатыря;
# В темнице там царевна тужит,
# А бурый волк ей верно служит;
# Там ступа с Бабою Ягой
# Идёт, бредёт сама собой,
# Там царь Кащей над златом чахнет;
# Там русский дух... там Русью пахнет!
# И там я был, и мёд я пил;
# У моря видел дуб зелёный;
# Под ним сидел, и кот учёный
# Свои мне сказки говорил.
# """
# text = text.lower() # привели все к нижнему регистру
# text = text.replace("\n", " ") # заменили символы перевода строки на пробел
# # заменим знаки пунктуации на пробелы
# text = text.replace(";", " ")
# text = text.replace(".", " ")
# text = text.replace("--", " ")
# list_2 = list(text.split())
# print(list_2)
# count = {}
# for word in list_2:
#     if word in count:
#         count[word] += 1
#     else:
#         count[word] = 1
# for char, cnt in count.items():
#    print(f"Слово {char} встречается {cnt} раз")



##чтобы при переборе всех чисел от 1 до 99 выводилось “число % 3”, если число кратно 3; “число % 5”, если число кратно 5; при этом все четные числа бы игнорировались
#1
# for i in range(1,100):
#     if i % 2 == 0:
#         continue
#     if i % 3 == 0:
#        print (f'{i} % 3')
#     if i % 5 == 0:
#        print (f'{i} % 5')




#*******************************************
# Итоговый проект модуля B3. Часть 2. Циклы.
# Необходимо определить, содержит ли число цифры 5, 7 или 9, работая только с числом, НЕ приводя его в строку

# # Выберем произвольное целое число
# n = 125538923975423
# # Создадим словарь, в котором в качестве ключей определим цифры "5,7,9,"
# # а в качестве исходных значений этих значений зададим "0".
# numbers = {5 : 0, 7 : 0, 9 : 0}
#
# print(f"Проанализируем исходное число {n} и определим количество вхождений в него цифр 5, 7, 9")
#
# # для решения задачи используем цикл while,
# # в рамках которого будем последовательного делить исходное число на "10",
# # сравнивая остаток от деления с содержимым нашего словаря.
# while n > 1:
#     if (n % 10) in numbers:
#         # если остаток от деления находится в словаре, то увеличиваем значение словаря по ключу на 1
#         numbers[(n % 10)] += 1
#     n = n//10 # осуществляем целочисленное деление, чтобы перейти к следующей итерации цикла while
#
# # По моей задумке алгоритм должен выводить в консоль сообщение об отсутствии в исходном числе цифр 5,7,9
# # Чтобы это реализовать последовательно сделаем следующее:
# # 1. с помощью функции values обратимся к списку значений словаря numbers: numbers.values()
# # 2. далее преобразуем эти значения в список с помощью функции list: list(numbers.values())
# # 3. затем с помощью функции count посчитаем количество "0" в списке: list(numbers.values()).count(0)
# # 4. и если таких нулей "3", то очевидно, что цифр 5,7,9 нет в исходном числе
# proverka = list(numbers.values()).count(0)
# if proverka == 3:
#     print("цифры 5, 7 или 9 отсутствуют в исходном числе")
# else:
#     # если не выполнено условие, то хотя бы одна цифра из заданных имеется в исходном числе
#     # используем цикл for для того, чтобы проанализировать содержимое нашего словаря и оформить вывод в консоль
#     for num, cnt in numbers.items():
#         print(f"Количество вхождений цифры {num} в исходное число составляет - {cnt}.")
# #*****************Конец*******************
# # Решение предыдущей задачи от авторов курса
# number = 11111
# digitToFind = 5
#
# num = number
# while num > 0:
#
#    digit = num % 10
#    if digit == digitToFind:
#        print(f"{digitToFind} is in number {number}")
#        break
#    num = int(num / 10)
#*************************************************************************

# Модуль B4. Функциональное программирование

# # Задание 4.2.1
# # Задание на самопроверку.
# #
# # Напишите функцию print_2_add_2, которая будет складывать 2 плюс 2 и печатать этот результат.
# # Не забудьте вызвать функцию, чтобы увидеть результат.
#
# def print_2_add_2():
#    result = 2 + 2
#    print(result)
#
# print_2_add_2()

# # Задание 4.2.2
# # Задание на самопроверку.
# # Напишите функцию hello_world, которая будет печать приветственную строку «Hello World».
# def hello_world():
#     print("Hello World")
# hello_world()
#
# # Задание 4.2.3
# # Напишите функцию, которая проверяет является ли число n, делителем числа a.
# # И выводит на экран соответствующее сообщение, является ли число делителем или нет.
# def delitel(a, n=1):
#     if a % n == 0:
#         print(f'Число {n} является делителем числа {a}')
#     else:
#         print(f'Число {n} НЕ является делителем числа {a}')
# delitel(5,5)

# # Задание 4.2.4
# # Напишите функцию, которая печатает “обратную лесенку” следующего типа:
#
# def lesenka(n=1):
#     while n>0:
#         print('*'*n)
#         n -=1
# lesenka(5)
# # Решение авторов курса
# def reverse_stair(n):
#    for i in range(n, 0, -1):
#        print("*" * i)
# reverse_stair(5)

# # Задание 4.2.5
# # Напишите функцию, которая будет возвращать количество делителей числа а.
# # Пример ввода: 5
# # Пример вывода программы: 2
#
# def cnt_delitel(a):
#     n=0
#     for i in range(a, 0, -1):
#         print(i)
#         if a % i == 0:
#             n=n+1
#     return n
#     #     print(f'Число {n} является делителем числа {a}')
#     # else:
#     #     print(f'Число {n} НЕ является делителем числа {a}')
# print(f'Количество делителей составляет - {cnt_delitel(100)}')

# # Задание 4.2.6
# # Напишите функцию, которая проверяет, является ли данная строка палиндромом или нет,
# # и возвращается результат проверки.
# # Пример:
# # check_palindrome("test")  # False
# # check_palindrome("Кит на море не романтик")  # True
# def check_palindrome(txt):
#     txt_check = txt.replace(" ", "").lower()
#     print(txt_check)
#     if txt_check == txt_check[::-1]:
#         return True
#     else:
#         return False
# print(check_palindrome('Кит на море не романтик'))

# # ЗАДАНИЕ 3.8.1 Напишите цикл, который ищет наибольший элемент в матрице.
# test_matrix = [
#                [1, 2252, 3],
#                [7, -1, 2],
#                [123, 2, -1]
#                ]
# # определим переменную max_value, которой присвоим значение первого элемента матрицы
# max_value = test_matrix[0][0]
# for row in test_matrix:
#     if max(row) > max_value: # сравнивание максимальное значение из элементов списка "row" со значением max_value
#         max_value = max(row) # если находим среди элементов списка "row" большое значение, то присваиваем это значение переменной max_value
#     print(f"Макс в {test_matrix.index(row)+1} ряду : {max(row)}") # выводим максимальное значение в строке
# print(f"Максимальное значение матрицы: {max_value}") # выводим максимальное значение в матрице

# # Задание 4.3.2
# # Задание на самопроверку.
# #
# # Написать функцию, которая будет перемножать любое количество переданных ей аргументов.
#
# def multyer(*nums):
#     multy_ = 1
#     for n in nums:
#         multy_ *= n
#
#     return multy_
#
#
# print(multyer())  # 1
# print(multyer(1))  # 1
# print(multyer(1, 2))  # 2
# print(multyer(1, 2, 3, 4)) #24

# # Задание 4.3.3
# # Задания на самопроверку.
# #
# # С помощью рекурсивной функции найдите сумму чисел от 1 до n.
#
# def sum(n):
#     s = n
#     if n == 0:
#         return s
#     # print('итерация сложения: ', s)
#     s += sum(n-1)
#     # print('Результат сложения: ', s)
#     return s
# print(sum(5))
# #!!!!!!!!!!!!!!!!!!! Решение от авторов
# def rec_sum(n):
#    if n == 1:  # терминальный случай
#        return 1
#    return n + rec_sum(n - 1)  # рекурсивный вызов
# print(rec_sum(5))

# # Задание 4.3.4
# # С помощью рекурсивной функции развернуть строку.
#
# def razstr(txt=''):
#     if txt == '':
#         return ''
#     return txt[::-1]
# print(razstr('test'))
#
# # Решение от авторов
# def reverse_str(string):
#    if len(string) == 0:
#        return ''
#    else:
#        return string[-1] + reverse_str(string[:-1])
#
# reverse_str('test')  # tset


# # Задание 4.3.5
# # Дано натуральное число N. Вычислите сумму его цифр.
# #
# # При решении этой задачи нельзя использовать строки, списки, массивы (ну и циклы, разумеется).
# def sum(N):
#     if N < 1:
#         return 0
#     return N%10 + sum(N//10)
# print(sum(1234))


# # Последовательность Фибоначчи
# def fib():
#     a, b = 0, 1
#     yield a
#     yield b
#     while True:
#         a, b = b, a+b
#         yield b
#
# for num in fib():
#     print(f" - {str(num)}")
#     if num > (10**1): break
# print('--------------------------------')
# for num in fib():
#     print(f" - {str(num)}")
#     if num > (10**3): break
# #***************************

# # Задание 4.4.1
# # Задание на самопроверку.
# #
# # Создать функцию-генератор, возвращающую бесконечную последовательность натуральных чисел.
# # По умолчанию, она начинается с единицы и шагом 1,
# # но пользователь может указать любой шаг и любое число в качестве аргумента функции,
# # с которого будет начинаться последовательность.
#
# def seq(start=1,step=1):
#     while True:
#         yield start
#         start += step
#
# for a in seq(1,1):
#     if a > 10:
#         break
#     print(a)
# # решение от авторов
# def count(start=1, step=1):
#     counter = start
#     while True:
#         yield counter
#         counter += step

# # Задание 4.4.2
# # Задание на самопроверку.
# # Создайте генератор, который по переданному списку создаёт последовательность,
# # в которой элементы этого списка бесконечно циклично повторяются.
# # Например, для списка [1, 2, 3] генератор создаст бесконечную последовательность 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, ... .
# def list_gen(list_=[]):
#     value = []
#     while True:
#         # print(f'value = {value}')
#         # print(f'list = {list_}')
#         value += list_
#         # print('end fun')
#         yield value
#
# it = list_gen([1,2,3])
# print(next(it))
# print(next(it))
# print(next(it))
# print(next(it))
# # !!!Мое решение НЕВЕРНОЕ и решает совершенно другую задачу!!!
# # решение авторов
#
# def repeat_list(list_):
#    list_values = list_.copy()
#    while True:
#        value = list_values.pop(0)
#        list_values.append(value)
#        yield value
#
# for i in repeat_list([1, 2, 3]):
#    print(i)

# # Иттераторы!!!!!
# t = ('a', 'b')
# tt= iter(t)
# print(iter(t))
# print(next(tt))
# l =[1,2,3]
# ll=iter(l)
# print(iter(l))
# print(next(ll))
# d = {'a':1, 'b':2}
# dd = iter(d)
# print(iter(d))
# print(next(dd))
# print(next(dd))
#
# s ='str'
# ss = iter(s)
# print(iter(s))
# print(next(ss))
# n = None
# print(iter(n))

#
# def mul(a):
#     def helper(b):
#         return a * b
#
#     return helper
#
# print(mul(5)(2))
#
# new_mul5 = mul(5)
# print(new_mul5)
# print(new_mul5(2))
# print(new_mul5(7))
#
#
# def fun1(a):
#     x = a * 3
#
#     def fun2(b):
#         nonlocal x
#         return b + x
#
#     return fun2
#
# test_fun = fun1(4)
# print(test_fun)
# print(test_fun(7))

# # Задание 4.5.1
# # Задание на самопроверку.
# #
# # Возьмите из предыдущего примера декорированные функции, которые возвращают время работы основной функции.
# # Найдите среднее время выполнения для 100 выполнений каждой функции.
# import time
#
# def decorator_time(fn):
#    def wrapper():
#        # print(f"Запустилась функция {fn}")
#        t0 = time.time()
#        result = fn()
#        dt = time.time() - t0
#        # print(f"Функция выполнилась. Время: {dt:.10f}")
#        return dt  # задекорированная функция будет возвращать время работы
#    wrapper.__name__ = fn.__name__
#    return wrapper
#
#
# def pow_2():
#    return 10000000 ** 2000
#
# def in_build_pow():
#    return pow(10000000, 2000)
#
#
#
# pow_2 = decorator_time(pow_2)
# in_build_pow = decorator_time(in_build_pow)
# result1,result2 = 0,0
# for i in range(100):
#     result1 += pow_2()
#     result2 += in_build_pow()
#
# print(f'среднее время выполнения функции {pow_2.__name__} за 100 иттераций, составляет: {result1/100}')
# print(f'среднее время выполнения функции {in_build_pow.__name__} за 100 иттераций, составляет: {result2/100}')

# # Задание 4.5.2
# # Напишите декоратор, который будет подсчитывать количество вызовов декорируемой функции.
# # Для хранения переменной содержащей, количество вызовов, используйте nonlocal область декоратора.
# 
# def counter(func):
# 
#     count = 0
#     def inner(*args, **kwargs):
#         nonlocal count
#         count += 1
#         print(f'Количество вызовов функции {summator.__name__} составляет {count}')
#         return func(*args, **kwargs)
#     inner.__name__ = func.__name__
#     return inner
# @counter
# def summator(a, b):
#     return a + b
# print(summator(3, 4))
# print(summator(5, 6))
# print(summator(10, 15))
# 
## *********************************************


# # Задание 4.5.3
# # Напишите декоратор, который будет сохранять результаты выполнения декорируемой функции в словаре.
# # Словарь должен находиться в nonlocal области в следующем формате:
# # по ключу располагается аргумент функции, по значению результат работы функции, например, {n: f(n)}.
# #
# # И при повторном вызове функции будет брать значение из словаря, а не вычислять заново.
# # То есть словарь можно считать промежуточной памятью на время работы программы, где будут храниться ранее вычисленные значения.
# # Исходная функция, которую нужно задекорировать имеет следующий вид и выполняет простое умножение на число 123456789.:
# # def f(n):
# #    return n * 123456789
#
# def decorate(func):
#     d = {}
#     def inner(n):
#         nonlocal d
#         # print(n,result)
#         if n in d.keys():
#             print(f'аргумент {n} уже использовался при вычислении функции, значение функции равно: {d.get(n)}')
#             return d.get(n)
#         else:
#             print(f'аргумент {n} ранее НЕ использовался при вычислении функции, значение функции равно: {func(n)}, значение словаря обновлено и распечатано ниже')
#             d[n] = func(n)
#             print(d)
#             return func(n)
#     return inner
#
# @decorate
# def f(n):
#    return n * 123456789
#
# f(1)
# f(2)
# f(3)
# # *************
# f(1)
#
# # авторское решение
# def cache(func):
#    cache_dict = {}
#    def wrapper(num):
#        nonlocal cache_dict
#        if num not in cache_dict:
#            cache_dict[num] = func(num)
#            print(f"Добавление результата в кэш: {cache_dict[num]}")
#        else:
#            print(f"Возвращение результата из кэша: {cache_dict[num]}")
#        print(f"Кэш {cache_dict}")
#        return cache_dict[num]
#    return wrapper
#
# # ************************************************************************


# a = "foo"
# b = "bar"

# print(1 and a or b)

# a = ""
# b = ""

# print(1 and a or b)


# # пусть a и b - переменные, которые мы хотим проверить
# if a and b:
#     print("Обе переменные истинные")
#     print(a,b)
# elif a or b:
#     print("Одна из переменных истинная")
#     print( a or b ) # печать значения одной переменной, которая является истинной
# else:
#     print("Обе переменные ложные")
# # #
# # Задание 5.3.9
# # проверить, является ли оно целым,
# # находится ли в определенном промежутке (например от 100 до 999 включительно),
# # да еще и делится ли на 2 и 3 одновременно
# a = int(input())
# if (type(a) is int) and (a in range(100,1000)) and (a%2 ==0) and (a%3 ==0):
#     print(f' число соответствует критериям')

# L = list(map(int, input().split()))
#
# print(not any(L))

# # Задание 5.3.13
# # При помощи генератора списков создайте таблицу умножения чисел от 1 до 10.
# table = [[i *j for j in range(1, 11)] for i in range(1, 11)]
# print(*table, sep="\n", end="\n\n")

# # Задание 5.3.14
# # Модифицируйте последний пример таким образом, чтобы в список сохранялось True,
# # если элемент четный, и False, если элемент нечетный.
# L = [int(input())%2 == 0 for i in range(5)]
# print(L)

#
# # Задание 5.3.15
# # А вот здесь нам и поможет использование функций all([ ]) и any([ ]).
# # Замените знаки «?» таким образом, чтобы программа выводила True, если есть хотя бы одно четное число.
#
# L = [int(input()) % 2 == 0 for i in range(5)]
# print( any(L))

# # Задание 5.3.16
# # Подумайте, как нужно записать логическое выражение, используя all([ ]) и any([ ]) над списком четности,
# # если его результат будет истинным тогда и только тогда, когда в списке есть хотя бы один четный и хотя бы один нечетный элемент.
# L = [2, 2, 1, 2, 2]
# L = [int(L[i]) % 2 == 0 for i in range(5)]
# print(any(L) and not all(L))

# # Задание 5.3.17
# # Используя функцию zip() внутри генераторов списков, вычислите поэлементные произведения списков L и M.
# L = [i for i in range(10)]
# M = [i for i in range(10,0,-1)]
# for a, b in zip(L,M):
#     print(a*b)
# # решение авторов
# N = [a*b for a,b in zip(L,M)]
# print(N)

# # Задание 5.3.18
# # Реализуйте программу, которая сжимает последовательность символов. На вход подается последовательность вида:
# # # aaabbccccdaa
# # Необходимо вывести строку, где каждая последовательность из одинаковых символов, идущих подряд, заменяется на один символ,
# # и длину этой последовательности (включая последовательности единичной длины). Вывод должен выглядеть так:
# #
# # a3b2c4d1a2
# s_1 = 'aaabbccccdaa'
# print(s_1)
# l = list(s_1)
# # print(l)
# l_2=[]
# count= 1
# for i in range(len(l)):
#     if i==0:
#         pass
#     elif l[i] == l[i-1]:
#         count += 1
#     else:
#         l_2.append(str(l[i-1])+str(count))
#         count = 1
# l_2.append(str(l[len(l)-1])+str(count))
# print("".join(map(str, l_2)))
# # решение авторов
# text = input()  # получаем строку
#
# last = text[0]  # сохраняем первый символ
# count = 0  # заводим счетчик
# result = ''  # и результирующую строку
#
# for c in text:
#     if c == last:  # если символ совпадает с сохраненным,
#         count += 1  # то увеличиваем счетчик
#     else:
#         result += last + str(count)  # иначе - записываем в результат
#         last = c  # и обновляем сохраненный символ с его счетчиком
#         count = 1
#
# result += last + str(count)  # и добавляем в результат последний символ
# print(result)

# # Задание 5.4.3
# # Задание на самопроверку.
# #
# # Напишите функцию D(a, b, c), возвращающую дискриминант квадратного уравнения.
#
# # a*x**2 + b*x + c = 0 - общий вид уравнения
# # D = b**2 - 4*a*c - дискриминант
# # Если D<0, то уравнение не имеет вещественных корней
# # Если D=0, то уравнение имеет один корень - x = -b/(2*a)
# # Если D>0, то уравнение имеет два корня
# # x1 = (-b - D**0.5)/(2*a)
# # x2 = (-b + D**0.5)/(2*a)
# #
# # P.S. D**0.5 - равносильно извлечению квадратного корня
# def D(a,b,c):
#     return b**2 - 4*a*c
#
# def quadratic_solve(a, b, c):
#
#     if D(a,b,c) <0:
#         return 'Нет вещественных корней'
#     elif D(a,b,c)==0:
#         return -b/(2*a)
#     else:
#         return (-b - D(a, b, c) ** 0.5) / (2 * a), (-b + D(a, b, c) ** 0.5) / (2 * a)
#
#
# print(D(-3,-2,3))
#
# print(quadratic_solve(-3,-2,3))
#
# L=[1, 0, -1]
# print(quadratic_solve(*L))
#
# M = {'a': 1,
#      'b': 0,
#      'c': -1}
#
# print(quadratic_solve(**M))
#
# # Задание 5.4.9
# # Напишите рекурсивную функцию, находящую минимальный элемент списка без использование циклов и встроенной функции min().
# # !!!! нерабочее решение
# # L=[4,3,5,1,2]
# # print(len(L))
# # mm=0
# # def M(L,i1,i2,count):
# #
# #     if count <= len(L)-1:
# #         if L[i1] <= L[i2]:
# #             mm = L[i1]
# #             count = max(i1, i2 + 1)
# #             print('i1=',i1,'i2=',i2, mm, 'count=',count)
# #             M(L,i1,i2+1,count)
# #             return mm
# #         else:
# #             mm = L[i2]
# #             count = max(i1 + 1, i2)
# #             print('i1=',i1,'i2=',i2, 'min=',mm,'count=',count)
# #             M(L, i1+1, i2, count)
# #             return mm
# #     print('pyfxtybt ', mm)
# #     return mm
# # itog = M(L,0,1,1)
# # print(itog)
#
# # решение авторов курса
# def min_list(L):
#     if len(L) == 1:
#         return L[0]
#     return L[0] if L[0] < min_list(L[1:]) else min_list(L[1:])

# # Задание 5.4.10
# # Напишите рекурсивную функцию, которая зеркально разворачивает число. Предполагается, что число не содержит нули.
# def mirror(a, res=0):
#     return mirror(a // 10, res*10 + a % 10) if a else res
# print(mirror(123,0))


# # Проверить является ли число нарцистическим
# def narcissistic( value ):
#     # Code away
#     narcis=0
#     l=str(value)
#     for i in range((len(l))):
#         narcis += (value%10)**len(l)
#         value = value // 10
#     if narcis == int(l):
#         return True
#     else:
#         return False
# print(narcissistic(0))

# Задание 5.4.11
# Сейчас попробуем реализовать функцию equal(N, S), проверяющую, совпадает ли сумма цифр числа N с числом S.
# При написании программы следует обратить внимание на то, что, если S стала отрицательной, то необходимо сразу вернуть False.

# # Мое решение с помощью циклов
# def equal(N, S):
#     if S < 0:
#         return False
#     else:
#         return N == sum(int(x) for x in str(S))
# print(equal(9, 54))
#
# # решение авторов с помощью рекурсии
# def equal(N, S):
#     if S < 0:
#         return False
#     if N < 10:
#         return N == S, print(N,S)
#     else:
#         return equal(N // 10, S - N % 10), print('N=',N,'S=',S)
# print(equal(1234, 10))
#
# # Задание 5.4.13
# # Задание на самопроверку.
# #
# # Реализуйте функцию-генератор, каждое значение которого — приближение числа e с некоторым числом n.
# def e():
#     n = 1
#
#     while True:
#         yield (1 + 1 / n) ** n
#         n += 1
#
# last = 0
# for a in e(): # e() - генератор
#     if (a - last) < 0.1: # ограничение на точность
#         print(a)
#         break # после достижения которого - завершаем цикл
#     else:
#         last = a # иначе - присваиваем новое значение

# # Задание 5.4.15
# # Реализуйте функцию-декоратор, которая проверяет доступ к функции по username пользователя.
# # Все username пользователей хранятся в глобальной области видимости в списке USERS.
# # При согласии пользователя на авторизацию ему предлагается ввести username, который также хранится в глобальной области видимости.
# # Функция должна использовать два декоратора: один для проверки авторизации вообще (реализован), второй — для проверки доступа.
# USERS = ['admin', 'guest', 'director', 'root', 'superstar']
# yesno = input("""Введите Y, если хотите авторизоваться или N,
#              если хотите продолжить работу как анонимный пользователь: """)
#
# auth = yesno == "Y"
# if auth:
#     username = input("Введите ваш username:")
#
# def has_access(func):
#     def wrapper():
#         global USERS
#         if username in USERS:
#             print("Авторизован как", username)
#             func()
#         else:
#             print("Доступ пользователю", username, "запрещен")
#     return wrapper
#
# def is_auth(func):
#     def wrapper():
#         if auth:
#             print("Пользователь авторизован")
#             func()
#         else:
#             print("Пользователь неавторизован. Функция выполнена не будет")
#     return wrapper
#
# @is_auth
# @has_access
# def from_db():
#     print("some data from database")
#
# from_db()

#
# # Задание 5.5.1
# # C помощью метода строки str.lower перевести все элементы списка в нижний регистр.
# L = ['THIS', 'IS', 'LOWER', 'STRING']
# print(list(map(str.lower,L)))

# # Пример использования множественных итераторов
#
# first_it = [1, 2, 3]
# second_it = [4, 5, 6, 7]
# print(list(map(pow, first_it, second_it)))
# #[1, 32, 729]

    # # Задание 5.5.2
    # # Отфильтровать из заданного списка только четные элементы.
    #
    # L= [-2, -1, 0, 1, -3, 2, -3]
    # def chet(number):
    #     return number%2 == 0
    # print(list(filter(chet,L)))

# # Задание 5.5.5
# # 1 point possible (graded)
# # Замените знаки «???» корректным выражением. Вывести длину каждого элемента в списке.
# #
# # (Следует использовать метод map)
# a = ["asd", "bbd", "ddsdfa", "mcsa"]
#
# print(list(map(len, a)))

# # Задание 5.5.6
# # 1 point possible (graded)
# # Замените знаки «?» корректным выражением. Переведите все строки из списка в верхний регистр (заглавные буквы).
#
# a = ["это", "маленький", "текст", "обидно"]
#
# print([x.upper() for x in a])
# print(list(map(str.upper, a)))

# 5.6. Итоговое практическое задание
# Игра крестики-нолики
field = [[" ", "1", '2', "3"],["1", "-", '-', "-"],["2", "-", '-', "-"],["3", "-", '-', "-"]]
for i in range(len(field)):
    # for j in range(len(i)):
    #     print(field[i][j])
    print(field[i])


